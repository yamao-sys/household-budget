/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Household Budget Service
 * household budget
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  CategoryTotalAmountListsResponse,
  ExpenseLists,
  GetExpensesCategoryTotalAmountsParams,
  GetExpensesParams,
  GetExpensesTotalAmountsParams,
  PostExpenses500,
  StoreExpenseInput,
  StoreExpenseResponse,
  TotalAmountListsResponse,
} from ".././model";

import { customFetch } from "../../custom-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get Expenses
 */
export type getExpensesResponse200 = {
  data: ExpenseLists;
  status: 200;
};

export type getExpensesResponseComposite = getExpensesResponse200;

export type getExpensesResponse = getExpensesResponseComposite & {
  headers: Headers;
};

export const getGetExpensesUrl = (params?: GetExpensesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/expenses?${stringifiedParams}` : `/expenses`;
};

export const getExpenses = async (params?: GetExpensesParams, options?: RequestInit): Promise<getExpensesResponse> => {
  return customFetch<getExpensesResponse>(getGetExpensesUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetExpensesQueryKey = (params?: GetExpensesParams) => {
  return [`/expenses`, ...(params ? [params] : [])] as const;
};

export const getGetExpensesQueryOptions = <TData = Awaited<ReturnType<typeof getExpenses>>, TError = unknown>(
  params?: GetExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExpensesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpenses>>> = ({ signal }) => getExpenses(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetExpensesQueryResult = NonNullable<Awaited<ReturnType<typeof getExpenses>>>;
export type GetExpensesQueryError = unknown;

export function useGetExpenses<TData = Awaited<ReturnType<typeof getExpenses>>, TError = unknown>(
  params: undefined | GetExpensesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getExpenses>>, TError, Awaited<ReturnType<typeof getExpenses>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpenses<TData = Awaited<ReturnType<typeof getExpenses>>, TError = unknown>(
  params?: GetExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getExpenses>>, TError, Awaited<ReturnType<typeof getExpenses>>>, "initialData">;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpenses<TData = Awaited<ReturnType<typeof getExpenses>>, TError = unknown>(
  params?: GetExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Expenses
 */

export function useGetExpenses<TData = Awaited<ReturnType<typeof getExpenses>>, TError = unknown>(
  params?: GetExpensesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpenses>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Post Expense
 */
export type postExpensesResponse200 = {
  data: StoreExpenseResponse;
  status: 200;
};

export type postExpensesResponse500 = {
  data: PostExpenses500;
  status: 500;
};

export type postExpensesResponseComposite = postExpensesResponse200 | postExpensesResponse500;

export type postExpensesResponse = postExpensesResponseComposite & {
  headers: Headers;
};

export const getPostExpensesUrl = () => {
  return `/expenses`;
};

export const postExpenses = async (storeExpenseInput: StoreExpenseInput, options?: RequestInit): Promise<postExpensesResponse> => {
  return customFetch<postExpensesResponse>(getPostExpensesUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(storeExpenseInput),
  });
};

export const getPostExpensesMutationOptions = <TError = PostExpenses500, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postExpenses>>, TError, { data: StoreExpenseInput }, TContext>;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof postExpenses>>, TError, { data: StoreExpenseInput }, TContext> => {
  const mutationKey = ["postExpenses"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postExpenses>>, { data: StoreExpenseInput }> = (props) => {
    const { data } = props ?? {};

    return postExpenses(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostExpensesMutationResult = NonNullable<Awaited<ReturnType<typeof postExpenses>>>;
export type PostExpensesMutationBody = StoreExpenseInput;
export type PostExpensesMutationError = PostExpenses500;

/**
 * @summary Post Expense
 */
export const usePostExpenses = <TError = PostExpenses500, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postExpenses>>, TError, { data: StoreExpenseInput }, TContext>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postExpenses>>, TError, { data: StoreExpenseInput }, TContext> => {
  const mutationOptions = getPostExpensesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get Expenses Category TotalAmounts
 */
export type getExpensesCategoryTotalAmountsResponse200 = {
  data: CategoryTotalAmountListsResponse;
  status: 200;
};

export type getExpensesCategoryTotalAmountsResponseComposite = getExpensesCategoryTotalAmountsResponse200;

export type getExpensesCategoryTotalAmountsResponse = getExpensesCategoryTotalAmountsResponseComposite & {
  headers: Headers;
};

export const getGetExpensesCategoryTotalAmountsUrl = (params: GetExpensesCategoryTotalAmountsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/expenses/categoryTotalAmounts?${stringifiedParams}` : `/expenses/categoryTotalAmounts`;
};

export const getExpensesCategoryTotalAmounts = async (
  params: GetExpensesCategoryTotalAmountsParams,
  options?: RequestInit,
): Promise<getExpensesCategoryTotalAmountsResponse> => {
  return customFetch<getExpensesCategoryTotalAmountsResponse>(getGetExpensesCategoryTotalAmountsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetExpensesCategoryTotalAmountsQueryKey = (params: GetExpensesCategoryTotalAmountsParams) => {
  return [`/expenses/categoryTotalAmounts`, ...(params ? [params] : [])] as const;
};

export const getGetExpensesCategoryTotalAmountsQueryOptions = <TData = Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError = unknown>(
  params: GetExpensesCategoryTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExpensesCategoryTotalAmountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>> = ({ signal }) =>
    getExpensesCategoryTotalAmounts(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetExpensesCategoryTotalAmountsQueryResult = NonNullable<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>>;
export type GetExpensesCategoryTotalAmountsQueryError = unknown;

export function useGetExpensesCategoryTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError = unknown>(
  params: GetExpensesCategoryTotalAmountsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>,
          TError,
          Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesCategoryTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError = unknown>(
  params: GetExpensesCategoryTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>,
          TError,
          Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesCategoryTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError = unknown>(
  params: GetExpensesCategoryTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Expenses Category TotalAmounts
 */

export function useGetExpensesCategoryTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError = unknown>(
  params: GetExpensesCategoryTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesCategoryTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensesCategoryTotalAmountsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Expense Total Amounts
 */
export type getExpensesTotalAmountsResponse200 = {
  data: TotalAmountListsResponse;
  status: 200;
};

export type getExpensesTotalAmountsResponseComposite = getExpensesTotalAmountsResponse200;

export type getExpensesTotalAmountsResponse = getExpensesTotalAmountsResponseComposite & {
  headers: Headers;
};

export const getGetExpensesTotalAmountsUrl = (params: GetExpensesTotalAmountsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/expenses/totalAmounts?${stringifiedParams}` : `/expenses/totalAmounts`;
};

export const getExpensesTotalAmounts = async (
  params: GetExpensesTotalAmountsParams,
  options?: RequestInit,
): Promise<getExpensesTotalAmountsResponse> => {
  return customFetch<getExpensesTotalAmountsResponse>(getGetExpensesTotalAmountsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetExpensesTotalAmountsQueryKey = (params: GetExpensesTotalAmountsParams) => {
  return [`/expenses/totalAmounts`, ...(params ? [params] : [])] as const;
};

export const getGetExpensesTotalAmountsQueryOptions = <TData = Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError = unknown>(
  params: GetExpensesTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExpensesTotalAmountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensesTotalAmounts>>> = ({ signal }) =>
    getExpensesTotalAmounts(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetExpensesTotalAmountsQueryResult = NonNullable<Awaited<ReturnType<typeof getExpensesTotalAmounts>>>;
export type GetExpensesTotalAmountsQueryError = unknown;

export function useGetExpensesTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError = unknown>(
  params: GetExpensesTotalAmountsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, Awaited<ReturnType<typeof getExpensesTotalAmounts>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError = unknown>(
  params: GetExpensesTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, Awaited<ReturnType<typeof getExpensesTotalAmounts>>>,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError = unknown>(
  params: GetExpensesTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Expense Total Amounts
 */

export function useGetExpensesTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError = unknown>(
  params: GetExpensesTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesTotalAmounts>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensesTotalAmountsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
