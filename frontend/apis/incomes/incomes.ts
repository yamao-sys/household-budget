/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * Household Budget Service
 * household budget
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ClientTotalAmountListsResponse,
  GetExpensesClientTotalAmountsParams,
  GetIncomesParams,
  GetIncomesTotalAmountsParams,
  IncomeLists,
  PostIncomes500,
  StoreIncomeInput,
  StoreIncomeResponse,
  TotalAmountListsResponse,
} from ".././model";

/**
 * @summary Get Incomes
 */
export type getIncomesResponse200 = {
  data: IncomeLists;
  status: 200;
};

export type getIncomesResponseComposite = getIncomesResponse200;

export type getIncomesResponse = getIncomesResponseComposite & {
  headers: Headers;
};

export const getGetIncomesUrl = (params?: GetIncomesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/incomes?${stringifiedParams}` : `/incomes`;
};

export const getIncomes = async (params?: GetIncomesParams, options?: RequestInit): Promise<getIncomesResponse> => {
  const res = await fetch(getGetIncomesUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getIncomesResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as getIncomesResponse;
};

export const getGetIncomesQueryKey = (params?: GetIncomesParams) => {
  return [`/incomes`, ...(params ? [params] : [])] as const;
};

export const getGetIncomesQueryOptions = <TData = Awaited<ReturnType<typeof getIncomes>>, TError = unknown>(
  params?: GetIncomesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData>>; fetch?: RequestInit },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncomesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncomes>>> = ({ signal }) => getIncomes(params, { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetIncomesQueryResult = NonNullable<Awaited<ReturnType<typeof getIncomes>>>;
export type GetIncomesQueryError = unknown;

export function useGetIncomes<TData = Awaited<ReturnType<typeof getIncomes>>, TError = unknown>(
  params: undefined | GetIncomesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData>> &
      Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncomes>>, TError, Awaited<ReturnType<typeof getIncomes>>>, "initialData">;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIncomes<TData = Awaited<ReturnType<typeof getIncomes>>, TError = unknown>(
  params?: GetIncomesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData>> &
      Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncomes>>, TError, Awaited<ReturnType<typeof getIncomes>>>, "initialData">;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIncomes<TData = Awaited<ReturnType<typeof getIncomes>>, TError = unknown>(
  params?: GetIncomesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Incomes
 */

export function useGetIncomes<TData = Awaited<ReturnType<typeof getIncomes>>, TError = unknown>(
  params?: GetIncomesParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomes>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIncomesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Post Income
 */
export type postIncomesResponse200 = {
  data: StoreIncomeResponse;
  status: 200;
};

export type postIncomesResponse500 = {
  data: PostIncomes500;
  status: 500;
};

export type postIncomesResponseComposite = postIncomesResponse200 | postIncomesResponse500;

export type postIncomesResponse = postIncomesResponseComposite & {
  headers: Headers;
};

export const getPostIncomesUrl = () => {
  return `/incomes`;
};

export const postIncomes = async (storeIncomeInput: StoreIncomeInput, options?: RequestInit): Promise<postIncomesResponse> => {
  const res = await fetch(getPostIncomesUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(storeIncomeInput),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postIncomesResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postIncomesResponse;
};

export const getPostIncomesMutationOptions = <TError = PostIncomes500, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIncomes>>, TError, { data: StoreIncomeInput }, TContext>;
  fetch?: RequestInit;
}): UseMutationOptions<Awaited<ReturnType<typeof postIncomes>>, TError, { data: StoreIncomeInput }, TContext> => {
  const mutationKey = ["postIncomes"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIncomes>>, { data: StoreIncomeInput }> = (props) => {
    const { data } = props ?? {};

    return postIncomes(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostIncomesMutationResult = NonNullable<Awaited<ReturnType<typeof postIncomes>>>;
export type PostIncomesMutationBody = StoreIncomeInput;
export type PostIncomesMutationError = PostIncomes500;

/**
 * @summary Post Income
 */
export const usePostIncomes = <TError = PostIncomes500, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postIncomes>>, TError, { data: StoreIncomeInput }, TContext>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postIncomes>>, TError, { data: StoreIncomeInput }, TContext> => {
  const mutationOptions = getPostIncomesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get Income Client TotalAmounts
 */
export type getExpensesClientTotalAmountsResponse200 = {
  data: ClientTotalAmountListsResponse;
  status: 200;
};

export type getExpensesClientTotalAmountsResponseComposite = getExpensesClientTotalAmountsResponse200;

export type getExpensesClientTotalAmountsResponse = getExpensesClientTotalAmountsResponseComposite & {
  headers: Headers;
};

export const getGetExpensesClientTotalAmountsUrl = (params?: GetExpensesClientTotalAmountsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/incomes/client-total-amounts?${stringifiedParams}` : `/incomes/client-total-amounts`;
};

export const getExpensesClientTotalAmounts = async (
  params?: GetExpensesClientTotalAmountsParams,
  options?: RequestInit,
): Promise<getExpensesClientTotalAmountsResponse> => {
  const res = await fetch(getGetExpensesClientTotalAmountsUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getExpensesClientTotalAmountsResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as getExpensesClientTotalAmountsResponse;
};

export const getGetExpensesClientTotalAmountsQueryKey = (params?: GetExpensesClientTotalAmountsParams) => {
  return [`/incomes/client-total-amounts`, ...(params ? [params] : [])] as const;
};

export const getGetExpensesClientTotalAmountsQueryOptions = <TData = Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError = unknown>(
  params?: GetExpensesClientTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExpensesClientTotalAmountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>> = ({ signal }) =>
    getExpensesClientTotalAmounts(params, { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetExpensesClientTotalAmountsQueryResult = NonNullable<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>>;
export type GetExpensesClientTotalAmountsQueryError = unknown;

export function useGetExpensesClientTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError = unknown>(
  params: undefined | GetExpensesClientTotalAmountsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>,
          TError,
          Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesClientTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError = unknown>(
  params?: GetExpensesClientTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>,
          TError,
          Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExpensesClientTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError = unknown>(
  params?: GetExpensesClientTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Income Client TotalAmounts
 */

export function useGetExpensesClientTotalAmounts<TData = Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError = unknown>(
  params?: GetExpensesClientTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getExpensesClientTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetExpensesClientTotalAmountsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Income Total Amounts
 */
export type getIncomesTotalAmountsResponse200 = {
  data: TotalAmountListsResponse;
  status: 200;
};

export type getIncomesTotalAmountsResponseComposite = getIncomesTotalAmountsResponse200;

export type getIncomesTotalAmountsResponse = getIncomesTotalAmountsResponseComposite & {
  headers: Headers;
};

export const getGetIncomesTotalAmountsUrl = (params?: GetIncomesTotalAmountsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/incomes/total-amounts?${stringifiedParams}` : `/incomes/total-amounts`;
};

export const getIncomesTotalAmounts = async (
  params?: GetIncomesTotalAmountsParams,
  options?: RequestInit,
): Promise<getIncomesTotalAmountsResponse> => {
  const res = await fetch(getGetIncomesTotalAmountsUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: getIncomesTotalAmountsResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as getIncomesTotalAmountsResponse;
};

export const getGetIncomesTotalAmountsQueryKey = (params?: GetIncomesTotalAmountsParams) => {
  return [`/incomes/total-amounts`, ...(params ? [params] : [])] as const;
};

export const getGetIncomesTotalAmountsQueryOptions = <TData = Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError = unknown>(
  params?: GetIncomesTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncomesTotalAmountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getIncomesTotalAmounts>>> = ({ signal }) =>
    getIncomesTotalAmounts(params, { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetIncomesTotalAmountsQueryResult = NonNullable<Awaited<ReturnType<typeof getIncomesTotalAmounts>>>;
export type GetIncomesTotalAmountsQueryError = unknown;

export function useGetIncomesTotalAmounts<TData = Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError = unknown>(
  params: undefined | GetIncomesTotalAmountsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, Awaited<ReturnType<typeof getIncomesTotalAmounts>>>,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIncomesTotalAmounts<TData = Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError = unknown>(
  params?: GetIncomesTotalAmountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, Awaited<ReturnType<typeof getIncomesTotalAmounts>>>,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetIncomesTotalAmounts<TData = Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError = unknown>(
  params?: GetIncomesTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Income Total Amounts
 */

export function useGetIncomesTotalAmounts<TData = Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError = unknown>(
  params?: GetIncomesTotalAmountsParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIncomesTotalAmounts>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetIncomesTotalAmountsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
