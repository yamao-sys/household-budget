/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * Household Budget Service
 * household budget
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  PostUsersCheckSignedIn200,
  PostUsersSignIn500,
  PostUsersSignUp500,
  PostUsersValidateSignUp500,
  UserSignInBadRequestResponse,
  UserSignInInput,
  UserSignInOkResponse,
  UserSignUpInput,
  UserSignUpResponse,
} from ".././model";

/**
 * @summary User Check Signed In
 */
export type postUsersCheckSignedInResponse200 = {
  data: PostUsersCheckSignedIn200;
  status: 200;
};

export type postUsersCheckSignedInResponseComposite = postUsersCheckSignedInResponse200;

export type postUsersCheckSignedInResponse = postUsersCheckSignedInResponseComposite & {
  headers: Headers;
};

export const getPostUsersCheckSignedInUrl = () => {
  return `/users/check-signed-in`;
};

export const postUsersCheckSignedIn = async (options?: RequestInit): Promise<postUsersCheckSignedInResponse> => {
  const res = await fetch(getPostUsersCheckSignedInUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postUsersCheckSignedInResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postUsersCheckSignedInResponse;
};

export const getPostUsersCheckSignedInQueryKey = () => {
  return [`/users/check-signed-in`] as const;
};

export const getPostUsersCheckSignedInQueryOptions = <TData = Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError = unknown>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData>>;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPostUsersCheckSignedInQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof postUsersCheckSignedIn>>> = ({ signal }) =>
    postUsersCheckSignedIn({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type PostUsersCheckSignedInQueryResult = NonNullable<Awaited<ReturnType<typeof postUsersCheckSignedIn>>>;
export type PostUsersCheckSignedInQueryError = unknown;

export function usePostUsersCheckSignedIn<TData = Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, Awaited<ReturnType<typeof postUsersCheckSignedIn>>>,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostUsersCheckSignedIn<TData = Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, Awaited<ReturnType<typeof postUsersCheckSignedIn>>>,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostUsersCheckSignedIn<TData = Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary User Check Signed In
 */

export function usePostUsersCheckSignedIn<TData = Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError = unknown>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postUsersCheckSignedIn>>, TError, TData>>; fetch?: RequestInit },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getPostUsersCheckSignedInQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary User Sign In
 */
export type postUsersSignInResponse200 = {
  data: UserSignInOkResponse;
  status: 200;
};

export type postUsersSignInResponse400 = {
  data: UserSignInBadRequestResponse;
  status: 400;
};

export type postUsersSignInResponse500 = {
  data: PostUsersSignIn500;
  status: 500;
};

export type postUsersSignInResponseComposite = postUsersSignInResponse200 | postUsersSignInResponse400 | postUsersSignInResponse500;

export type postUsersSignInResponse = postUsersSignInResponseComposite & {
  headers: Headers;
};

export const getPostUsersSignInUrl = () => {
  return `/users/sign-in`;
};

export const postUsersSignIn = async (userSignInInput: UserSignInInput, options?: RequestInit): Promise<postUsersSignInResponse> => {
  const res = await fetch(getPostUsersSignInUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userSignInInput),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postUsersSignInResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postUsersSignInResponse;
};

export const getPostUsersSignInMutationOptions = <TError = UserSignInBadRequestResponse | PostUsersSignIn500, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext>;
  fetch?: RequestInit;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext> => {
  const mutationKey = ["postUsersSignIn"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersSignIn>>, { data: UserSignInInput }> = (props) => {
    const { data } = props ?? {};

    return postUsersSignIn(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersSignInMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersSignIn>>>;
export type PostUsersSignInMutationBody = UserSignInInput;
export type PostUsersSignInMutationError = UserSignInBadRequestResponse | PostUsersSignIn500;

/**
 * @summary User Sign In
 */
export const usePostUsersSignIn = <TError = UserSignInBadRequestResponse | PostUsersSignIn500, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersSignIn>>, TError, { data: UserSignInInput }, TContext> => {
  const mutationOptions = getPostUsersSignInMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary User Sign Up
 */
export type postUsersSignUpResponse200 = {
  data: UserSignUpResponse;
  status: 200;
};

export type postUsersSignUpResponse400 = {
  data: UserSignUpResponse;
  status: 400;
};

export type postUsersSignUpResponse500 = {
  data: PostUsersSignUp500;
  status: 500;
};

export type postUsersSignUpResponseComposite = postUsersSignUpResponse200 | postUsersSignUpResponse400 | postUsersSignUpResponse500;

export type postUsersSignUpResponse = postUsersSignUpResponseComposite & {
  headers: Headers;
};

export const getPostUsersSignUpUrl = () => {
  return `/users/sign-up`;
};

export const postUsersSignUp = async (userSignUpInput: UserSignUpInput, options?: RequestInit): Promise<postUsersSignUpResponse> => {
  const res = await fetch(getPostUsersSignUpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userSignUpInput),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postUsersSignUpResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postUsersSignUpResponse;
};

export const getPostUsersSignUpMutationOptions = <TError = UserSignUpResponse | PostUsersSignUp500, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext>;
  fetch?: RequestInit;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationKey = ["postUsersSignUp"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersSignUp>>, { data: UserSignUpInput }> = (props) => {
    const { data } = props ?? {};

    return postUsersSignUp(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersSignUpMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersSignUp>>>;
export type PostUsersSignUpMutationBody = UserSignUpInput;
export type PostUsersSignUpMutationError = UserSignUpResponse | PostUsersSignUp500;

/**
 * @summary User Sign Up
 */
export const usePostUsersSignUp = <TError = UserSignUpResponse | PostUsersSignUp500, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationOptions = getPostUsersSignUpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary User Validate Sign Up
 */
export type postUsersValidateSignUpResponse200 = {
  data: UserSignUpResponse;
  status: 200;
};

export type postUsersValidateSignUpResponse400 = {
  data: UserSignUpResponse;
  status: 400;
};

export type postUsersValidateSignUpResponse500 = {
  data: PostUsersValidateSignUp500;
  status: 500;
};

export type postUsersValidateSignUpResponseComposite =
  | postUsersValidateSignUpResponse200
  | postUsersValidateSignUpResponse400
  | postUsersValidateSignUpResponse500;

export type postUsersValidateSignUpResponse = postUsersValidateSignUpResponseComposite & {
  headers: Headers;
};

export const getPostUsersValidateSignUpUrl = () => {
  return `/users/validate-sign-up`;
};

export const postUsersValidateSignUp = async (userSignUpInput: UserSignUpInput, options?: RequestInit): Promise<postUsersValidateSignUpResponse> => {
  const res = await fetch(getPostUsersValidateSignUpUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(userSignUpInput),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  const data: postUsersValidateSignUpResponse["data"] = body ? JSON.parse(body) : {};

  return { data, status: res.status, headers: res.headers } as postUsersValidateSignUpResponse;
};

export const getPostUsersValidateSignUpMutationOptions = <TError = UserSignUpResponse | PostUsersValidateSignUp500, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersValidateSignUp>>, TError, { data: UserSignUpInput }, TContext>;
  fetch?: RequestInit;
}): UseMutationOptions<Awaited<ReturnType<typeof postUsersValidateSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationKey = ["postUsersValidateSignUp"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersValidateSignUp>>, { data: UserSignUpInput }> = (props) => {
    const { data } = props ?? {};

    return postUsersValidateSignUp(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUsersValidateSignUpMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersValidateSignUp>>>;
export type PostUsersValidateSignUpMutationBody = UserSignUpInput;
export type PostUsersValidateSignUpMutationError = UserSignUpResponse | PostUsersValidateSignUp500;

/**
 * @summary User Validate Sign Up
 */
export const usePostUsersValidateSignUp = <TError = UserSignUpResponse | PostUsersValidateSignUp500, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUsersValidateSignUp>>, TError, { data: UserSignUpInput }, TContext>;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postUsersValidateSignUp>>, TError, { data: UserSignUpInput }, TContext> => {
  const mutationOptions = getPostUsersValidateSignUpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
